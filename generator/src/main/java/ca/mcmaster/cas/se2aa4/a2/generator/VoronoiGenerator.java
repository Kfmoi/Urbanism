package ca.mcmaster.cas.se2aa4.a2.generator;

import org.locationtech.jts.geom.*;
import org.locationtech.jts.triangulate.*;

import ca.mcmaster.cas.se2aa4.a2.components.Vertex;
import ca.mcmaster.cas.se2aa4.a2.components.Vert;
import ca.mcmaster.cas.se2aa4.a2.components.Segment;
import ca.mcmaster.cas.se2aa4.a2.components.Seg;
import ca.mcmaster.cas.se2aa4.a2.components.Poly;
import org.locationtech.jts.algorithm.ConvexHull;


import ca.mcmaster.cas.se2aa4.a2.mesh.Mesh;
import java.util.*;

public class VoronoiGenerator implements Generator {

    private final Random randomX, randomY;
    private final int numPoints, relaxationLevel;
    final static PrecisionModel HUNDREDTH_PRECISION_MODEL = new PrecisionModel(100);
    final static double NINE_TENTHS = 0.9;
    public final static int MIN_NUM_POINTS = 20, MIN_RELAXATION_LEVEL = 0;

    public VoronoiGenerator(int numPoints, int relaxationLevel) {
        this.numPoints = Math.max(numPoints, MIN_NUM_POINTS);
        this.relaxationLevel = Math.max(relaxationLevel, MIN_RELAXATION_LEVEL);
        randomX = new Random();
        randomY = new Random();
        warnUser(numPoints, MIN_NUM_POINTS, "NUMBER POINTS");
        warnUser(relaxationLevel, MIN_RELAXATION_LEVEL, "RELAXATION LEVEL");
    }

    public VoronoiGenerator(int numPoints, int relaxationLevel, long seedX, long seedY) {
        this.numPoints = Math.max(numPoints, MIN_NUM_POINTS);
        this.relaxationLevel = Math.max(relaxationLevel, MIN_RELAXATION_LEVEL);
        randomX = new Random(seedX);
        randomY = new Random(seedY);
        warnUser(numPoints, MIN_NUM_POINTS, "NUMBER POINTS");
        warnUser(relaxationLevel, MIN_RELAXATION_LEVEL, "RELAXATION LEVEL");
    }

    static void warnUser(int givenValue, int defaultValue, String subject) {
        if (givenValue < defaultValue) {
            System.out.println(String.format(
                    "WARNING: The given value of %1$s was set below the minimum value of %2$s for argument %3$s. Setting %3$s to Default value %2$s",
                    givenValue, defaultValue, subject));
        }

    }

    @Override
    public void generate(final Mesh mesh) {
        List<Coordinate> randCoord = RandomCoords(mesh.getHeight(), mesh.getWidth());
        List<Polygon> polygons = createPolygons(randCoord, mesh.getHeight(), mesh.getWidth());
        for (int i = 0; i < relaxationLevel; i++) {
            randCoord = relaxAllCentroids(polygons, mesh.getHeight(), mesh.getWidth());
            polygons = createPolygons(randCoord, mesh.getHeight(), mesh.getWidth());
        }
        List<Coordinate> deulayneyPol = relaxAllCentroids(polygons, mesh.getHeight(), mesh.getWidth());
        List<Polygon> deulPoly = delaunayGen(deulayneyPol);

        List<Poly> finalPolys = convertPolygons(polygons, deulPoly, mesh.getHeight(), mesh.getWidth());

        addAllComponents(mesh, finalPolys);
    }

    /**
     * Adds all the necessary components generated by the polygon to the given mesh.
     *
     * @param mesh     the Mesh to add all components to.
     * @param polygons the list of Polygons from which all relevant components are
     *                 generated.
     */
    void addAllComponents(final Mesh mesh, final List<Poly> polygons) {
        Vert v;
        Seg s;
        List<double[]> vertices;
        for (Poly p : polygons) {
            vertices = p.getVertexList();
            // Add the first vertex of this polygon
            v = new Vertex(vertices.get(0)[0], vertices.get(0)[1]);
            mesh.addVert(v);
            // Add remaining vertices, and since they are ordered radially, they are
            // adjacent to the vertices before and after them.
            // As a result, a segment can be made with this vertex and the vertex before, so
            // add that as well.
            for (int i = 1; i < vertices.size(); i++) {
                v = new Vertex(vertices.get(i)[0], vertices.get(i)[1]);
                mesh.addVert(v);
                s = new Segment(vertices.get(i - 1)[0], vertices.get(i - 1)[1], vertices.get(i)[0], vertices.get(i)[1]);
                mesh.addSeg(s);
            }
            // Add the segment that connects the first vertex with the last one.
            s = new Segment(vertices.get(0)[0], vertices.get(0)[1], vertices.get(vertices.size() - 1)[0],
                    vertices.get(vertices.size() - 1)[1]);
            mesh.addSeg(s);
            mesh.addPoly(p);
        }
    }

    public List<Polygon> createPolygons(List<Coordinate> coords, int height, int width) {
        GeometryFactory geomfactory = new GeometryFactory(HUNDREDTH_PRECISION_MODEL);
        VoronoiDiagramBuilder voronoiBuilder = new VoronoiDiagramBuilder();
        Envelope size = new Envelope(0, width, 0, height);
        voronoiBuilder.setClipEnvelope(size);
        voronoiBuilder.setSites(coords);

        Geometry createdPolys = voronoiBuilder.getSubdivision().getVoronoiDiagram(geomfactory);

        List<Polygon> polygonList = new ArrayList<>();

        GeometryCollection geomCollection = (GeometryCollection) createdPolys;
        for (int j = 0; j < geomCollection.getNumGeometries(); j++) {
            Polygon polygon = (Polygon) geomCollection.getGeometryN(j);
            polygonList.add(polygon);

        }

        Collections.sort(polygonList, new PolygonComparator());
        return polygonList;
    }

    List<Coordinate> RandomCoords(final int height, final int width) {
        List<Coordinate> coords = new ArrayList<>();

        for (int i = 1; i < numPoints; i++) {
            int pointX = randomX.nextInt((int) Math.ceil(height * NINE_TENTHS + 1));
            int pointY = randomY.nextInt((int) Math.ceil(width * NINE_TENTHS + 1));
            coords.add(new Coordinate(pointX, pointY));
        }
        return coords;
    }
    

    private List<double[]> getVertices(final Polygon polygon) {
        GeometryFactory geomFactory = new GeometryFactory(HUNDREDTH_PRECISION_MODEL);
        Coordinate[] coordinates = new Coordinate[10];
        List<double[]> vertices = new ArrayList<>();
        coordinates = polygon.getCoordinates();
        ConvexHull convexHull = new ConvexHull(coordinates, geomFactory);
        Geometry convexPoly = convexHull.getConvexHull();
        for (Coordinate c : convexPoly.getCoordinates()) {
            vertices.add(new double[] { c.getX(), c.getY() });
        }

        return vertices;
    }

    private List<Poly> convertPolygons(final List<Polygon> voronoi, final List<Polygon> delauney, int height,
            int width) {
        final List<Poly> polys = new ArrayList<>();
        ca.mcmaster.cas.se2aa4.a2.components.Polygon p, p1, p2;
        p1 = new ca.mcmaster.cas.se2aa4.a2.components.Polygon();
        p2 = new ca.mcmaster.cas.se2aa4.a2.components.Polygon();
        Set<Seg> segSet = new TreeSet<>();
        for (Polygon dPoly : delauney) {
            Coordinate[] coordinates = dPoly.getCoordinates();
            Seg s1 = new Segment(coordinates[0].getX(), coordinates[0].getY(),
            coordinates[1].getX(), coordinates[1].getY());
            Seg s2 = new Segment(coordinates[0].getX(), coordinates[0].getY(),
            coordinates[2].getX(), coordinates[2].getY());
            Seg s3 = new Segment(coordinates[2].getX(), coordinates[2].getY(),
            coordinates[1].getX(), coordinates[1].getY());
            segSet.add(s1);
            segSet.add(s2);
            segSet.add(s3);
        }

        for (Polygon polygon : voronoi) {
            Coordinate centroidCoord = boundCentroid(polygon, height, width);
            p = new ca.mcmaster.cas.se2aa4.a2.components.Polygon(centroidCoord.getX(), centroidCoord.getY());
            p.setVertices(getVertices(polygon));
            p.setNeighbours(new ArrayList<>());
            polys.add(p);
        }
        //sorting polygons to assign neighbours
        Collections.sort(polys);
        List<List<double[]>> neighboursList = new ArrayList<>();
        for (int i = 0; i < polys.size(); i++) {
            neighboursList.add(new ArrayList<>());
        }
        for (Seg seg : segSet) {
            p1.setCentroid(seg.getX1(), seg.getY1());
            p2.setCentroid(seg.getX2(), seg.getY2());
            int idx1 = Collections.binarySearch(polys, p1);
            int idx2 = Collections.binarySearch(polys, p2);
            neighboursList.get(idx1).add(new double[] { seg.getX2(), seg.getY2() });
            neighboursList.get(idx2).add(new double[] { seg.getX1(), seg.getY1() });
        }
        for (int i = 0; i < polys.size(); i++) {
            polys.get(i).setNeighbours(neighboursList.get(i));
        }

        return polys;
    }

    // returns coordinate list to pass into createPolygon to smoothen shapes using
    // Lloyd relaxation
    List<Coordinate> getCentroids(final List<Polygon> polygons) {
        List<Coordinate> centroids = new ArrayList<>();
        for (Polygon p : polygons) {
            centroids.add(new Coordinate(p.getCentroid().getX(), p.getCentroid().getY()));
        }
        centroids.sort(Comparator.comparing(Coordinate::getX).thenComparing(Coordinate::getY));
        return centroids;
    }

    Coordinate boundCentroid(final Polygon p, int height, int width) {
        double x = p.getCentroid().getX();
        double y = p.getCentroid().getY();
        x = Math.min(Math.max(x, 0), width);
        y = Math.min(Math.max(y, 0), height);
        return new Coordinate(x, y);
    }

    List<Coordinate> relaxAllCentroids(final List<Polygon> polygons, int height, int width) {
        List<Coordinate> centroids = new ArrayList<>();
        for (Polygon p : polygons) {
            centroids.add(boundCentroid(p, height, width));
        }
        centroids.sort(Comparator.comparing(Coordinate::getX).thenComparing(Coordinate::getY));
        return centroids;
    }

    double[] convertCentroid(final Polygon polygon) {
        return new double[] { polygon.getCentroid().getX(), polygon.getCentroid().getY() };

    }

    List<Polygon> delaunayGen(List<Coordinate> coords) {

        GeometryFactory geomfactory = new GeometryFactory(HUNDREDTH_PRECISION_MODEL);
        DelaunayTriangulationBuilder dBuilder = new DelaunayTriangulationBuilder();
        dBuilder.setSites(coords);
        Geometry createdPolys = dBuilder.getTriangles(geomfactory);
        List<Polygon> triangleList = new ArrayList<>();

        GeometryCollection geomCollection = (GeometryCollection) createdPolys;
        for (int j = 0; j < geomCollection.getNumGeometries(); j++) {
            Polygon polygon = (Polygon) geomCollection.getGeometryN(j);
            triangleList.add(polygon);
        }
        return triangleList;
    }

    private class PolygonComparator implements Comparator<Polygon> {
        @Override
        public int compare(Polygon p1, Polygon p2) {
            int comp = Double.compare(p1.getCentroid().getX(), p2.getCentroid().getX());
            if (comp != 0) {
                return comp;
            }
            return Double.compare(p1.getCentroid().getY(), p2.getCentroid().getY());
        }
    }

}